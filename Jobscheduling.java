/*

## 알고리즘 1

// 작업을 가장 빨리 종료하기 위해서는 그리디 알고리즘을 이용하는데 현재까지 배정된 작업에 대해 가장 빨리 끝나는 기계에 새 작업을 배정하는 방법을 사용한다. 해당 알고리즘은 아래와 같다.

1.      for j = 1 to m             // 처음 기계에 아직 작업을 배정 받지 않았기 때문에 0으로 초기화, 기계는 1부터 시작
2.         L[j] = 0                // L[j] = 기계 m_j에 배정된 마지막 작업의 종료 시간
3.        for i = 1 to n             // n개의 작업을 1개씩 가장 일찍 끝내는 기게에 배정
4.          { min = 1                // min은 가장 일찍 끝나는 기계여서 1로 초기화
5.          for j = 2 to m         // 각 기계의 마지막 작업의 종료 시간을 검사해서 min을 찾음
6.              { if (L[j] < L[min])
7.                  min = j }
8.          작업 i를 기계 m_min에 배정함   // 작업 i를 기계 m_min에 배정
9.          L[min] = L[min] + t_i }       // L[min]을 작업 i의 수행 시간을 더하여 갱신
10.      return 가장 늦은 작업 종료 시간   // 배열 L에서 가장 큰 값을 찾아서 리턴



## 알고리즘 2

// 이 알고리즘은 빠른 시작시간 작업을 우선으로 배정하는 방법을 이용한 알고리즘이다.

1.      시작 시간의 오름차순으로 정렬한 작업 리스트를 L이라고 한다.
2.      while (L ≠ ∅) {
3.       L에서 가장 이른 시작시간을 가진 작업 t_i를 가져온다.
4.        if (t_i를 수행할 기계가 있으면)
5.          ti를 수행할 수 있는 기계에 배정한다.
6.        else
7.          새로운 기계에 t_i를 배정한다.
8.        t_i를 L에서 제거한다.}
9.      return 각 기계에 배정된 작업 순서

*/
