# Job scheduling

## 201902949 이정수

--------------------------------------------------

## Job scheduling

 n개의 작업과 각 작업의 수행시간인 t_i(i=1, 2, 3,..., n)이 있고 m개의 기계인 m_j(j=1,2,3,...,m)가 주어질때 작업 스케줄링 문제는 수행 시간이 중복되지 않도록 작업이 가장 빨리 종료될 수 있게 모든 작업을 기계에 배정하는 문제이다.
한 작업은 배정된 기계에서 연속적으로 수행되어야 하고 기계는 한 번에 하나의 작업만을 수행할 수 있다.


## 알고리즘 1

작업을 가장 빨리 종료하기 위해서는 그리디 알고리즘을 이용하는데 현재까지 배정된 작업에 대해 가장 빨리 끝나는 기계에 새 작업을 배정하는 방법을 사용한다. 해당 알고리즘은 아래와 같다.

1.      for j = 1 to m             // 처음 기계에 아직 작업을 배정 받지 않았기 때문에 0으로 초기화, 기계는 1부터 시작
2.         L[j] = 0                // L[j] = 기계 m_j에 배정된 마지막 작업의 종료 시간
3.        for i = 1 to n             // n개의 작업을 1개씩 가장 일찍 끝내는 기게에 배정
4.          { min = 1                // min은 가장 일찍 끝나는 기계여서 1로 초기화
5.          for j = 2 to m         // 각 기계의 마지막 작업의 종료 시간을 검사해서 min을 찾음
6.              { if (L[j] < L[min])
7.                  min = j }
8.          작업 i를 기계 m_min에 배정함   // 작업 i를 기계 m_min에 배정 
9.          L[min] = L[min] + t_i }       // L[min]을 작업 i의 수행 시간을 더하여 갱신   
10.      return 가장 늦은 작업 종료 시간   // 배열 L에서 가장 큰 값을 찾아서 리턴



## 알고리즘 2

이 알고리즘은 빠른 시작시간 작업을 우선으로 배정하는 방법을 이용한 알고리즘이다.

1.      시작 시간의 오름차순으로 정렬한 작업 리스트를 L이라고 한다.
2.      while (L ≠ ∅) {
3.       L에서 가장 이른 시작시간을 가진 작업 t_i를 가져온다.
4.        if (t_i를 수행할 기계가 있으면)
5.          ti를 수행할 수 있는 기계에 배정한다.
6.        else
7.          새로운 기계에 t_i를 배정한다.
8.        t_i를 L에서 제거한다.}
9.      return 각 기계에 배정된 작업 순서



## 문제

문제: 작업의 개수 n과 기계의 개수 m이 각각 다음과 같을 때 시간복잡도와 근사비율을 구하여라.

n = [2, 3, 4, 5], m = 2  

풀이:

작업의 수행 시간이 2, 3, 4, 5 이고 2개의 기계가 있을 경우 처음에는 2, 3이 배정이 되고 작업이 빨리 끝나는 기계에 다음 순서가 배정되므로 2 다음 4가 배정이 되고 3 다음 5가 배정이 된다.
아래의 그림을 통해 자세히 더 알 수 있다. (1번~4번은 순서를 나타낸 것, 흰색 부분은 2,3이 배정된 것을 나타내고 파란 부분은 4,5가 배정된 것을 나타냄, t_i는 작업 5의 수행시간임)

![1](https://user-images.githubusercontent.com/81748368/118560030-d40b6180-b7a3-11eb-91bf-69b56519b105.PNG)

 

### 시간복잡도

#### 알고리즘 1

알고리즘 1의 시간복잡도는 n개의 작업을 배정하고 line 10번에서 배열 L에서 가장 큰 값을 찾아서 리턴해야 하기 때문에 n * O(m) + O(m) = O(mn)이 된다.
따라서 시간복잡도는 O(mn) 시간이다.

#### 알고리즘 2

line 1번에서 n개의 작업을 오름차순으로 정렬하는 데 O(nlogn) 시간이 걸린다.
while문에서 작업을 t_i를 L에서 제거하고 새로운 기게에 배정하므로 O(m)이 걸리고 while 문이 n번 반복하므로 line 5~12는 O(m)*n = O(mn) 시간이 걸린다.
총 합을 구하면 시간복잡도는 O(nlogn) + O(nm)시간이 된다.


## 근사비율

알고리즘 1의 근사비율은 다음과 같다.

알고리즘 1의 근사해를 OPT'라고 하고 최적해를 OPT라 할 때 OPT'는 OPT의 2배보다 같거나 작다. 가장 마지막으로 배정된 작업 5가 T부터 수행되었고 모든 작업이 T + t_i에 종료되었으므로 OPT'= T + t_i이다. 또한 T'는 마지막 작업인 작업 5를 제외한 평균 종료 시간이다. T'= (2+3+4)/3=4.5 이고 T=3이므로 T ≤ T'임을 알 수 있다.
따라서 정리를 하면 다음과 같다. 

OPT'= T + t_i  ≤ t_i + T'

               ≤ OPT + (1 - (1/m))*OPT 
               
               = (2 - (1/m))*OPT
               
               ≤ 2OPT

